<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="../../resources/css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Merriweather:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../resources/android-chrome-512x512-removebg-preview.png" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v6.0.0-beta1/css/all.css">
  <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <title>Quantum Computing</title>
</head>
<body>
    <header class="header">
        <a href="../../index.html" class="header__name"><h1>J<span class="header__full-stop">.</span> Wills</h1></a>
        <a href="../../index.html" class="header__initials"><h1>J<span class="header__full-stop">.</span>W<span class="header__full-stop">.</span></h1></a>
        
        <nav class="header__socials">
          <a href="https://github.com/jamesjwills" target="_blank" class="header__socials-item"><i class="fa-brands fa-github"></i></a>
          <a href="linkedin.com/in/jamesjwills" target="_blank" class="header__socials-item"><i class="fa-brands fa-linkedin-in"></i></a>
        </nav>
    </header>

    <main class="about">
      <section class="about__intro">
        <section class="about__intro__name">
            <h2 class="about__intro__name--full-name">Bluff Your Way In:</h2>
            <h2 class="about__intro__name--full-name">Quantum Computing</h2>
        </section>
                <section class="about__intro__blurb">
            <a class="blurb__contents"><h3>Contents</h3></a>
            <a class="blurb__title"><h3>Bluff Your Way In: Quantum Computing</h3></a>
            <nav class="table-of-contents">
                <li><a href="#introduction"
                id="toc-introduction">INTRODUCTION</a></li>
                <li><a href="#superposition-and-entanglement"
                id="toc-superposition-and-entanglement">SUPERPOSITION
                AND ENTANGLEMENT</a></li>
                <li><a
                href="#feynman-and-the-genesis-of-quantum-computation"
                id="toc-feynman-and-the-genesis-of-quantum-computation">FEYNMAN
                AND THE GENESIS OF QUANTUM COMPUTATION</a></li>
                <li><a href="#are-quantum-computers-better"
                id="toc-are-quantum-computers-better">ARE QUANTUM
                COMPUTERS ‘BETTER’?</a></li>
                <li><a href="#are-quantum-computers-more-capable"
                id="toc-are-quantum-computers-more-capable">ARE QUANTUM
                COMPUTERS MORE ‘CAPABLE’?</a></li>
                <li><a href="#whence-the-power-of-quantum-computing"
                id="toc-whence-the-power-of-quantum-computing">WHENCE
                THE POWER OF QUANTUM COMPUTING?</a></li>
                <li><a href="#bluff-your-way"
                id="toc-bluff-your-way">BLUFF YOUR WAY</a></li>
                <li><a href="#further-reading"
                id="toc-further-reading">FURTHER READING</a></li>
                </ul></li>
                </ul>
            </nav>
        </section>
              </section>

      <section class="about__content">
        <div class="about__projects">
          <h2 id="introduction">INTRODUCTION</h2>
          <p>It is a habit of philosophers to ask annoying questions.
          Ask “What is a quantum computer?” and you will likely receive
          the response “Well, what is a (classical) computer, anyway?”
          (the “anyway” is very important…) But questions which may seem
          annoying can be deep and fascinating. The question “what is a
          computer?” let alone “what is a quantum computer?” is one such
          question.</p>
          <p>Let’s begin by making an important distinction: that
          between the abstract notion of a computer and the concrete
          implementation of it. There are computer-instances everywhere
          - your phone, laptop, watch or calculator. In the last
          century, some computer-instances were human. But they are all
          computers - they all instantiate the abstract notion of
          “computer”. Although they are programmed to perform different
          functions, they all do fundamentally the same thing: they all
          consist of a <em>state</em> and some <em>rules</em> for
          changing that state.</p>
          <p>For classical computers, the state is a sequence of
          <em>bits</em> which can take one of two values (0 or 1) and
          the rules for changing this sequence of bits are given by the
          <em>logic gates</em>. Quantum computers are still computers:
          they consist of a state and rules for changing that state. But
          in this case, the state is represented as a sequence of
          quantum bits or <em>qubits</em> and the rules for changing
          that state are represented by <em>quantum logic
          gates</em>.</p>
          <p>Still, although this may technically answer our question,
          it does not enlighten us. One of the questions we really want
          insight on, of course, it what it is about qubits and quantum
          logic gates which give quantum computing its supposed
          advantage over classical computers. Which inherently quantum
          feature is responsible for, or explains, the advantage? And
          what is that advantage (anyway)?</p>
          <h2 id="superposition-and-entanglement">SUPERPOSITION AND
          ENTANGLEMENT</h2>
          <p>Two fundamental concepts in quantum theory are often linked
          to the explanation of quantum speedup: superposition and
          entanglement. We must try to understand these to get insight
          into our question.</p>
          <p>Despite people’s best efforts, there is no simultaneously
          precise and comprehensible explication of these ideas. Various
          attempts usually exhibit a trade-off between precision and
          comprehensibility. I choose to be precise: these ideas are
          quantum, and therefore non-classical, and therefore not
          amenable to classical explications. And since we generally go
          about understanding the world through a classical lens,
          quantum theory is going to be tough to get a grip on.</p>
          <p><strong>Superposition</strong>: if the state of a qubit can
          be <span class="math inline">\(|0\rangle\)</span> or <span
          class="math inline">\(|1\rangle\)</span> then another possible
          state of the qubit is <span
          class="math inline">\(\alpha|0\rangle +
          \beta|1\rangle\)</span>, where <span
          class="math inline">\(\alpha\)</span> and <span
          class="math inline">\(\beta\)</span> are complex numbers such
          that <span
          class="math inline">\(|\alpha|^2+|\beta|^2=1\)</span>.</p>
          <p><strong>Entanglement</strong>: the global state of two
          entangled systems cannot be described in terms of the state of
          the individual systems.</p>
          <p>All hope of insight or understanding is not lost entirely,
          however. Much understanding of superposition and entanglement
          can be gained with a sensible and careful comparison between
          classical and quantum states. Here is a simple example of the
          state of a 4-bit classical computer:</p>
          <p><span class="math display">\[
          0_{A}1_{B}1_{C}0_{D} 
          \]</span></p>
          <p>This says: bit <span class="math inline">\(A\)</span> has
          state 0, bit <span class="math inline">\(B\)</span> has state
          1, bit <span class="math inline">\(C\)</span> has state <span
          class="math inline">\(1\)</span> and bit <span
          class="math inline">\(D\)</span> has state <span
          class="math inline">\(0\)</span>. This makes the state of the
          computer as a whole, the global state, just the collection of
          the individual states of the classical bits. This is all there
          is to say about the state of classical computers.</p>
          <p>For a 4-qubit quantum computer, it is possible to have an
          exactly analogous situation:</p>
          <p><span class="math display">\[
          |0\rangle_{A}|1\rangle_{B}|1\rangle_{C}|0\rangle_{D}
          \]</span></p>
          <p>This says that qubit <span class="math inline">\(A\)</span>
          has state <span class="math inline">\(|0\rangle\)</span>,
          qubit <span class="math inline">\(B\)</span> has state <span
          class="math inline">\(|1\rangle\)</span> qubit <span
          class="math inline">\(C\)</span> has state <span
          class="math inline">\(|1\rangle\)</span> and qubit <span
          class="math inline">\(D\)</span> has state <span
          class="math inline">\(|0\rangle\)</span>. This makes the state
          of the computer as a whole, the global state, just the
          collection of the individual states of the qubits. But this is
          certainly not all there is to say about quantum computers.</p>
          <p>Because of superposition, if <span
          class="math inline">\(|0\rangle_A\)</span> and <span
          class="math inline">\(|1\rangle_A\)</span> are possible states
          of qubit <span class="math inline">\(A\)</span>, then <span
          class="math inline">\(\alpha|1\rangle_A +
          \beta|0\rangle_A\)</span> is also a possible state of qubit
          <span class="math inline">\(A\)</span>. This linear
          superposition is a mathematical fact of quantum theory. The
          interpretation of <span
          class="math inline">\(|1\rangle\)</span> and <span
          class="math inline">\(|0\rangle\)</span> as states of the
          qubit is what generates the weirdness: how is it possible for
          the qubit to be simultaneously in states <span
          class="math inline">\(|0\rangle\)</span> and <span
          class="math inline">\(|1\rangle\)</span>? By contrast, to say
          that <span class="math inline">\(0_A + 1_A\)</span> is a
          possible classical state of bit <span
          class="math inline">\(A\)</span> is just nonsense.</p>
          <p>On to entanglement. The explication I gave above said that
          the joint, or “global”, state of entangled quantum systems
          <span class="math inline">\(A\)</span> and <span
          class="math inline">\(B\)</span> cannot be broken down into
          the individual states of <span
          class="math inline">\(A\)</span> and <span
          class="math inline">\(B\)</span>. To understand why this is
          totally bizarre, consider the global state of the 4-bit
          classical computer I described above: in this case, the global
          state is described precisely by listing the state of the
          individual bits. In fact, it is hard to imagine any other way
          of describing the global state other than just saying what
          state its constituent parts are in. We may say in this case
          that the parts are prior to the whole. In a similar way, we
          have the global state of the 4-qubit quantum system explained
          above. This state can be described in terms of the state of
          its parts because it is not an entangled quantum state.</p>
          <p>But here is an example of an entangled quantum state: <span
          class="math inline">\(|1\rangle_A|0\rangle_B +
          |0\rangle_A|1\rangle_B\)</span>. In this case, we say that
          systems <span class="math inline">\(A\)</span> and <span
          class="math inline">\(B\)</span> are entangled. This state
          cannot be broken down (mathematically speaking, factorized)
          into the state of <span class="math inline">\(A\)</span> and
          the state of <span class="math inline">\(B\)</span>. It is
          just mathematically impossible to describe the global state in
          terms of the individual states. In fact, it is not a stretch
          to say that, for this state, <span
          class="math inline">\(A\)</span> and <span
          class="math inline">\(B\)</span> do not have well-defined
          individual states. They only have a well-defined joint, global
          state. In a sense then, for entangled states, somehow the
          whole is prior to the parts.</p>
          <h2
          id="feynman-and-the-genesis-of-quantum-computation">FEYNMAN
          AND THE GENESIS OF QUANTUM COMPUTATION</h2>
          <p>With this understanding under our belts, we are in a
          position to think about why quantum computers were conceived
          in the first place. What sort of problems were quantum
          computers meant to crack, and why can’t existing classical
          computers do it?</p>
          <p>This insight from Richard Feynman, right at the genesis of
          quantum computation, answers these questions:</p>
          <blockquote>
          <p>“The rule of simulation that I would like to have is that
          the number of computer elements required to simulate a large
          physical system is only to be proportional to the space-time
          volume of the physical system. I don’t want to have an
          explosion. That is, if you say I want to explain this much
          physics, I can do it exactly and I need a certain-sized
          computer. If doubling the volume of space and time means I’ll
          need an exponentially larger computer, I consider that against
          the rules (I make up the rules, I’m allowed to do that).”</p>
          </blockquote>
          <p>Feynman’s ‘rule’ aims to place a sanity constraint on the
          size of computer used to model a physical system. Suppose we
          have a physical system which requires a computer of a certain
          size to model. Then suppose we come across a physical system
          twice the size. If the size of the computer doubles, fine. If
          the size of the computer increases by, say factor <span
          class="math inline">\(4=2^2\)</span>, not fine, because this
          would be an “exponentially larger computer”. If four times the
          size of computer for twice the size of the physical system
          might not seem bad, consider a physical system ten times the
          size.</p>
          <p>On this understanding, this would require a computer <span
          class="math inline">\(2^{10}=1024\)</span> times bigger. We
          end up in a situation where the model does not scale
          manageably with the size of the system; it scales
          exponentially. Therefore, as the size of the system increases,
          it quickly becomes impossible to model; very quickly, as we
          scale the physical system, the computers become either
          unbuildable or take too long to run the program.</p>
          <p>But this is all speaking abstractly. A concrete example of
          this phenomenon is where we try to model quantum systems with
          classical computers. Indeed, this is exactly what Feynman had
          in mind, and is of particular relevance to chemistry where
          scientists attempt to model molecules as quantum systems on
          classical (super) computers. To understand why such modelling
          is so difficult, according to Feynman, I will give a simple
          argument for why the size of classical computer required to
          model quantum systems scales exponentially with the size of
          the quantum system.</p>
          <p>Consider a two classical-bit system: they can be in one of
          <span class="math inline">\(2^2=4\)</span> possible states
          <span class="math inline">\(0_A0_B\)</span>, <span
          class="math inline">\(0_A1_B\)</span>, <span
          class="math inline">\(1_A0_B\)</span> and <span
          class="math inline">\(1_A1_B\)</span>. For <span
          class="math inline">\(n\)</span> bits, there are <span
          class="math inline">\(2^n\)</span> possible states. Now
          consider a two qubit system. Initially, the situation looks
          similar: we can have four possible ‘basis’ states <span
          class="math inline">\(|0\rangle_A|0\rangle_B\)</span>, <span
          class="math inline">\(|0\rangle_A|1\rangle_B\)</span>, <span
          class="math inline">\(|1\rangle_A|0\rangle_B\)</span> and
          <span class="math inline">\(|1\rangle_A|1\rangle_B\)</span>.
          But because of superposition, now <span
          class="math inline">\(\alpha|00\rangle +\beta|01\rangle
          +\gamma|10\rangle +\delta|11\rangle\)</span> (where <span
          class="math inline">\(\alpha\)</span>, <span
          class="math inline">\(\beta\)</span>, <span
          class="math inline">\(\gamma\)</span> and <span
          class="math inline">\(\delta\)</span> are complex numbers such
          that <span
          class="math inline">\(|\alpha|^2+|\beta|^2+|\gamma|^2+|\delta|^2=1\)</span>)
          also counts as a possible state of the computer, in addition
          to the four basis states already listed. How many more bits of
          information are required now to describe the state of this
          quantum system? Since we need more bits to store the
          information about the numbers <span
          class="math inline">\(\alpha\)</span>, <span
          class="math inline">\(\beta\)</span>, <span
          class="math inline">\(\gamma\)</span>, <span
          class="math inline">\(\delta\)</span> we need <span
          class="math inline">\(4=2^2\)</span> more bits. For <span
          class="math inline">\(n\)</span> bits we need <span
          class="math inline">\(2^n\)</span> more bits to classically
          model the quantum state. (In fact it’s at least <span
          class="math inline">\(2.2^n\)</span> because these constants
          are complex numbers for which need two real numbers to
          represent). The point is, because you also need to represent
          these constants and there are <span
          class="math inline">\(2^n\)</span> of them, this represents
          the exponential blow-up in the size of computer needed to
          model this quantum system.</p>
          <h2 id="are-quantum-computers-better">ARE QUANTUM COMPUTERS
          ‘BETTER’?</h2>
          <p>If that explains why you will find it difficult to model
          quantum systems on a classical computer, it doesn’t really
          explain why quantum computers are somehow “better” or “more
          performant” than classical computers. Let’s explore what that
          might mean. I think the result of this exploration is rather
          surprising. To give a preview, let’s consider what we might
          mean by “better”. Here are some plausible interpretations of
          “better”. Does “better” mean:</p>
          <ol type="1">
          <li>More compact?</li>
          <li>Easier to build?</li>
          <li>Faster?</li>
          <li>More capable?</li>
          </ol>
          <p>The answers, which I think are rather surprising are “No”,
          “No”, “It depends” and “No”. I will explain shortly what I
          mean by “capable”.</p>
          <p>I’m going to focus on interpretations 3 and 4. The way I
          see it, these are the fundamental questions, whereas 1 and 2
          really speak to the engineering problems in building quantum
          computers, something I do not touch on here.</p>
          <p>To begin with 3. What does it mean for one computer to be
          “faster” than another? There are two senses of “fast”, as I
          see it. The laptop or phone you are reading this on is faster
          than the bricks we had back in the year 2000 because it has
          more processing power and can run whatever algorithm in a
          shorter time. This is due to better hardware design, usually
          in the form of greater transistor density. This sense of
          “fast” is a hardware innovation. Is this the sense in which
          quantum computers are faster? No. Of course, some
          quantum-computer-instance may be faster in this sense than
          some classical-computer-instance (no doubt modern quantum
          computers are faster at Algorithm A then
          classical-computer-instances of yesteryear). Some classical
          computer-instance may be faster than some other
          quantum-computer-instance. Some quantum computer-instances are
          faster than other quantum-computer-instances at returning the
          result of an algorithm. But this is not the sense of “fast”
          meant in the context of quantum speedup.</p>
          <p>Another sense of “fast” is this. Algorithm B may be faster
          at returning a result than Algorithm A for some problem. For
          example, we know that the General Number Field Sieve (GNFS)
          algorithm is more performant than the Trial Division Algorithm
          for factorising integers into their prime factors; in general,
          it would take Trial Division much longer than GNFS to
          factorise the number.</p>
          <p>The existence of faster algorithms is partly due to the
          creativity of mathematicians in designing more performant
          algorithms. Algorithm design is an inherently creative
          endeavour. It must be, for if it were not creative, it would
          be algorithmic, and if there were an algorithm for generating
          better algorithms to solve a particular problem, we would have
          all the best algorithms already. And we don’t, so algorithm
          design is creative.</p>
          <p>But it is crucial to remember that the performance of
          algorithms is strictly constrained by the architecture of the
          computer they run on. Classical algorithms are those
          algorithms which run on a classical computer and are designed
          with the architecture of the classical computer in mind: the
          algorithm tries to make the most efficient use of the
          classical bits and logic gates implemented in the hardware to
          solve the problem efficiently. A good example of this is the
          Quicksort sorting algorithm. It uses a divide-and-conquer
          approach that aligns with sequential processing nature of
          classical computers, implements in-place sorting to minimize
          memory usage, and leverages cache efficiency through its
          partitioning strategy. These characteristics make quicksort
          particularly well-suited for classical CPUs, demonstrating how
          algorithms are optimised and designed for specific hardware
          architectures.</p>
          <p>Quantum computers, as we have already seen, have a
          fundamentally different build architecture to classical
          computers. This fact opens up a whole new landscape of quantum
          algorithm design: algorithms which make full use of the
          qubits, quantum logic gates and the uniquely quantum features
          of superposition, entanglement (and interference, but I do not
          touch on this here).</p>
          <p>In integer prime factorisation, the most famous context of
          algorithm design, we have seen quantum algorithms beat
          classical algorithms by huge margins; Shor’s algorithm,
          designed for the quantum computer architecture, makes use of
          quantum features to factorise integers exponentially faster
          than known classical algorithms can.</p>
          <p>Thus we have seen, initially at least, that the reason for
          quantum speed up is not the hardware the computer is built out
          of but rather the underlying architecture design of the
          computer, allowing algorithms to be designed to take full
          advantage of that architecture resulting in much more
          performant algorithms.</p>
          <p>In short, quantum computers are faster, not because of
          better hardware, but because of the new quantum computer
          architecture on which new quantum algorithms can be designed
          and run. Quantum computing represents not just a new type of
          machine, but a fundamentally different way of thinking about
          computation.</p>
          <h2 id="are-quantum-computers-more-capable">ARE QUANTUM
          COMPUTERS MORE ‘CAPABLE’?</h2>
          <p>By this I mean: can a quantum computer solve problems which
          a classical computer cannot? This is a tempting, though false,
          thought. Here is a simple argument which proves this
          point:</p>
          <ol type="1">
          <li>Classical computers are Turing-complete.</li>
          <li>Classical computations can be simulated on quantum
          computers and vice versa.</li>
          <li>Therefore, quantum computers are Turing-complete.</li>
          <li>Therefore, quantum computers have no computational
          advantage (in this sense) over classical computers.</li>
          </ol>
          <p>This is not to say, of course, that quantum computers have
          no computational advantage at all over classical computers.
          This is just to say that the set of problems that they are
          each able to solve is exactly the same. It’s just that, as we
          have already seen, quantum computers can perhaps solve some of
          them much more quickly.</p>
          <p>But questions remain, even regarding this point. Granted,
          in the case of integer prime factorisation, there is the
          famous example of Shor’s algorithm, which trumps all classical
          algorithms at this particular problem. But is it the case
          that, for every problem solvable with a classical algorithm, a
          quantum algorithm exists which solves it in a significantly
          quicker time? No. Is there any way to know or decide whether,
          for a given classical problem-solution, a quantum solution
          exists? No.</p>
          <p>Why not? Because, as I claimed earlier, the designing of
          algorithms to run on a particular computer architecture is an
          inherently creative activity. Quantum computers are not simply
          ‘better’ than classical ones. It is perfectly plausible that
          many problems (of course, we don’t know which) won’t benefit
          from quantum computing and thus classical computers may well
          remain superior for some tasks. The best we can say about
          quantum computers is: they might be better at solving
          particular problems but we don’t know which. The advantage of
          quantum computers is highly problem-specific.</p>
          <h2 id="whence-the-power-of-quantum-computing">WHENCE THE
          POWER OF QUANTUM COMPUTING?</h2>
          <p>But let us turn to those problems at which we know quantum
          computers excel, those problems for which we know we have more
          performant algorithms. There are further fascinating questions
          to ask: given that we have a more performant algorithm, what
          aspect of the quantum architecture is truly ‘responsible’ for
          its performance? The guiding thought here is that there must
          be a reason, located in the difference between classical and
          quantum computer architecture, located in the difference
          between the laws of classical bits and the laws of qubits, why
          such a performant algorithm is possible.</p>
          <p>One suggestion is that it is the uniquely quantum
          phenomenon of superposition which is responsible for the
          quantum speedup. The argument goes, since the qubit exists in
          a real superposition of different states, any operation on
          that qubit as part of the computation operates
          ‘simultaneously’ on all parts of the superposition and thus
          you have a kind of parallel computation. It is generally
          considered uncontroversial that this kind of ‘quantum
          parallelism’ is at least partially responsible for quantum
          speedup. But there is also ongoing foundational research into
          the extent to which entanglement and quantum interference
          (which I have not discussed here) contributes to the quantum
          speedup in certain cases. No doubt the real answer to this
          question is that all quantum features are to some extent
          ‘responsible’. But can’t we do better than this? Might it be
          the case that some algorithms leverage superposition for the
          quantum speedup, while for others entanglement or interference
          play a more significant role?</p>
          <h2 id="bluff-your-way">BLUFF YOUR WAY</h2>
          <p>To bluff your way in quantum computing, you should be able
          to:</p>
          <ol type="1">
          <li>Describe superposition and use it to explain the
          exponential growth in quantum state space.</li>
          <li>Emphasize that quantum computers are faster for some
          specific problems, not universally.</li>
          <li>Highlight that quantum computers aren’t more capable than
          classical computers in terms of computability.</li>
          <li>Stress that the quantum speedup is fundamentally about
          algorithm design, not hardware.</li>
          </ol>
          <h2 id="further-reading">FURTHER READING</h2>
          <ul>
          <li><a
          href="https://s2.smu.edu/~mitch/class/5395/papers/feynman-quantum-1981.pdf">Richard
          Feynman: Simulating Physics with Computers</a></li>
          <li><a
          href="https://plato.stanford.edu/entries/qt-quantcomp/">Michael
          Cuffaro: Quantum Computing (SEP entry)</a></li>
          <li><a href="https://scottaaronson.blog/">Scott Aaronson:
          Blog</a></li>
          <li><a
          href="https://www.scientificamerican.com/article/the-limits-of-quantum-computers/">Scott
          Aaronson: The Limits of Quantum Computers</a></li>
          </ul>
        </div>
      </section>

    </main>
</body>
</html>